* Introduction

This file is a literate Elisp file; this approach is inspired by
[[https://github.com/patrickt/emacs]].

** Preamble

Enable lexical scope.

#+begin_src emacs-lisp
;; -*- coding: utf-8; lexical-binding: t -*-
#+end_src

Help out garbage collection performance.

#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)
#+end_src

Ensure all packages are installed, if necessary.

#+begin_src emacs-lisp
  ;; (setq use-package-always-ensure t)
#+end_src

** A note on package management

I don't like that MELPA et al. don't allow rollbacks. To solve this, I
track all installed packages in a Git repository. This might be a
terrible idea, but so far it works well enough (and how often do I
ever need to roll back? Still, it's nice to have.) I clone the
[[https://github.com/prsteele/emacs-elpa][emacs-elpa]] repository to the ~elpa/~ directory. (I clone directly
instead of using `git submodule` so that package update operations
modify an actual Git repository, which makes committing new changes
easy.)

You can, of course, simply not do this. This configuration doesn't
know this happening, so that directory can just be a regular old
directory.

* Configuration
** Cruft

Somehow, ~LD_PRELOAD~ is set. Unset it.

#+begin_src emacs-lisp
(setenv "LD_PRELOAD" "")
#+end_src

Define a customization group for my variables.

#+begin_src emacs-lisp
(defgroup prsteele nil
  "My customizations."
  :prefix "prsteele-"
  :group 'applications)
#+end_src

** General

We keep customization variables elsewhere.

#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

The prefix ~C-x C-x~ is easier on the hands than ~M-x~.

#+begin_src emacs-lisp
  (bind-key* "C-x C-x" #'execute-extended-command)
#+end_src

It's nice to have ~PATH~ set as you might expect, and this package
helps do so:

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

I've run into issues where libraries assume that ~tramp~ is loaded,
and it doesn't hurt to do so.

#+begin_src emacs-lisp
  (require 'tramp)
#+end_src

It's nice to pull in keychain information.

#+begin_src emacs-lisp
  (use-package keychain-environment
    :config
    (keychain-refresh-environment))
#+end_src

These are taken directly from [[https://github.com/patrickt/emacs]]:

#+begin_src emacs-lisp
(setq
 ;; No need to see GNU agitprop.
 inhibit-startup-screen t
 ;; No need to remind me what a scratch buffer is.
 initial-scratch-message nil
 ;; Double-spaces after periods is morally wrong.
 sentence-end-double-space nil
 ;; Never ding at me, ever.
 ring-bell-function 'ignore
 ;; Save existing clipboard text into the kill ring before replacing it.
 save-interprogram-paste-before-kill t
 ;; Prompts should go in the minibuffer, not in a GUI.
 use-dialog-box nil
 ;; Fix undo in commands affecting the mark.
 mark-even-if-inactive nil
 ;; Let C-k delete the whole line.
 kill-whole-line t
 ;; search should be case-sensitive by default
 case-fold-search nil
 ;; no need to prompt for the read command _every_ time
 compilation-read-command nil
 ;; scroll to first error
 compilation-scroll-output 'first-error
 ;; accept 'y' or 'n' instead of yes/no
 ;; the documentation advises against setting this variable
 ;; the documentation can get bent imo
 use-short-answers t
 ;; eke out a little more scrolling performance
 fast-but-imprecise-scrolling t
 ;; prefer newer elisp files
 load-prefer-newer t
 ;; when I say to quit, I mean quit
 confirm-kill-processes nil
 ;; if native-comp is having trouble, there's not very much I can do
 native-comp-async-report-warnings-errors 'silent
 ;; unicode ellipses are better
 truncate-string-ellipsis "…"
 ;; I want to close these fast, so switch to it so I can just hit 'q'
 help-window-select t
 ;; this certainly can't hurt anything
 delete-by-moving-to-trash t
 )
#+end_src

Use spaces, not tabs.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Use UTF-8 by default.

#+begin_src emacs-lisp
(set-charset-priority 'unicode)
(prefer-coding-system 'utf-8-unix)
#+end_src

Allow highlighted text to be deleted:

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

Some commands are disabled by default, and I don't want warnings when
I invoke them.

#+begin_src emacs-lisp
(mapc
 #'(lambda (x) (put x 'disabled nil))
 '(upcase-region
   downcase-region
   narrow-to-region))
#+end_src

I don't want backup files and so on.

#+begin_src emacs-lisp
  (setq
   make-backup-files nil
   auto-save-default nil
   create-lockfiles nil)
#+end_src

I usually want two buffers visible.

#+begin_src emacs-lisp
  (defun revert-to-two-windows ()
    "Delete all other windows and split it into two."
    (interactive)
    (delete-other-windows)
    (split-window-right))

  (bind-key "C-x 1" #'revert-to-two-windows)
  (bind-key "C-x !" #'delete-other-windows)
#+end_src

** Appearance

Show line and column numbers everywhere:

#+begin_src emacs-lisp
(global-display-line-numbers-mode t)
(column-number-mode)
#+end_src

Parenthesis matching and visual column numbers are useful.

#+begin_src emacs-lisp
(show-paren-mode 't)
#+end_src

Set fonts here.

#+begin_src emacs-lisp
  (set-frame-font "Noto Sans Mono 12")
#+end_src

[[https://ethanschoonover.com/solarized/][Solarized]] is a nice color scheme. Additionally, I find labeling
delimiters and words with different colors useful.

#+begin_src emacs-lisp
(use-package solarized-theme
  :init
  (load-theme 'solarized-dark t))
#+end_src

I like both delimiters an unique identifiers to have color coding.

#+begin_src emacs-lisp
(use-package rainbow-delimiters)
(use-package rainbow-identifiers)
#+end_src

This is needed to avoid small gaps around graphical Emacs on some
systems.

#+begin_src emacs-lisp
(setq frame-resize-pixelwise t)
#+end_src

I don't want trailing whitespace.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (setq require-final-newline t)
#+end_src

Some modes are noisy with visible trailing whitespace, and aren't saved.

#+begin_src emacs-lisp
(use-package compile
  :hook
  ((compilation-mode . disable-trailing-whitespace)))

(use-package shell
  :hook
  ((shell-mode . disable-trailing-whitespace)))

(use-package term
  :hook
  ((term-mode . disable-trailing-whitespace)))

#+end_src

** General modes
*** Flymake

Diminish it, and avoid the creation of temporary files. (The temporary
files can wreak havoc on sufficiently advanced IDE features.)

#+begin_src emacs-lisp
(use-package flymake
  :diminish
  :custom
  (flymake-run-in-place nil))
#+end_src

*** Helm

I use Helm for narrowing and completion.

#+begin_src emacs-lisp
(use-package helm-config)

(use-package helm
  :diminish
  :config
  (global-unset-key (kbd "C-x c"))
  (global-unset-key (kbd "C-x C-x"))

  :bind
  (("M-x" . helm-M-x)
   ("C-x C-x" . helm-M-x)
   ("C-x b" . helm-buffers-list)
   ("C-h SPC" . helm-all-mark-rings)
   ("C-x C-f" . helm-find-files)
   (:map helm-command-map
         (("<tab>" . helm-execute-persistent-action)
          ("C-i" . helm-execute-persistent-action)
          ("C-z" . helm-select-action))))

  :bind-keymap
  ("C-c h" . helm-command-prefix)


  :custom
  (helm-quick-update t)
  (helm-split-window-in-side-p t)
  (helm-buffers-fuzzy-matching t)
  (helm-move-to-line-cycle-in-source t)
  (helm-ff-search-library-in-sexp t)
  (helm-scroll-amount 8)
  (helm-ff-file-name-history-use-recentf t)
  (helm-buffer-max-length . nil)

  :init
  (helm-mode 1))

(use-package helm-grep
  :bind
  (:map helm-grep-mode-map
        ("<return>" . helm-grep-mode-jump-other-window)
        ("n" . helm-grep-mode-jump-other-window-forward)
        ("p" . helm-grep-mode-jump-other-window-backward)))

(use-package helm-eshell)
(use-package helm-files)
#+end_src

*** LSP

I use `lsp-mode` and `lsp-ui-mode` as my frontend for the various
language server protocol servers. This configuration should largely
follow what is suggested on [[https://github.com/emacs-lsp/lsp-mode][their home page]].

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands lsp
  :diminish "LSP"
  :hook
  ((lsp-mode . lsp-enable-which-key-integration))
  :custom
  (lsp-enable-snippet nil)
  (lsp-prefer-flymake nil)
  (lsp-signature-auto-activate nil)
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.hypothesis\\'")
  )

(use-package lsp-ui
  :commands lsp-ui-mode

 :bind
 (:map lsp-ui-mode-map
       ("C-c ?" . 'lsp-ui-doc-show-or-focus)
       ("C-." . 'lsp-ui-peek-find-definitions)
       ("M-." . 'lsp-ui-peek-find-references)
       ("C-," . 'xref-pop-marker-stack)
       ("C-c r" . 'lsp-rename)))

(defun lsp-ui-doc-show-or-focus (arg)
  (interactive "P")
  (if arg
      (lsp-ui-doc-focus-frame)
    (lsp-ui-doc-show)))

(use-package lsp-ui-doc
  ;; :hook
  ;; ((lsp-ui-doc-frame . (lambda (frame window) (message "got here"))))
  :bind
  (:map lsp-ui-doc-frame-mode-map
        ("C-c ?" . 'lsp-ui-doc-unfocus-frame)))

(add-hook
 'lsp-ui-doc-frame-hook
 (lambda (frame window)
   (set-frame-font "Noto Sans Mono 12" nil (list frame))))
#+end_src

We want to hook into Helm:

#+begin_src emacs-lisp
(use-package helm-lsp
  :commands helm-lsp-workspace-symbol)
#+end_src

I sometimes use ~eglot~ instead of ~lsp-mode~, so I leave its
configuration intact.

#+begin_src emacs-lisp
(use-package eglot
  :bind
  (:map eglot-mode-map
        ("C-." . 'xref-find-definitions)
        ("C-," . 'xref-pop-marker-stack)
        ("C-c ?" . 'eglot-help-at-point)
        ("C-c C-c" . 'eglot-code-actions)))
#+end_src

*** Magit

Nothing exotic.

#+begin_src emacs-lisp
(use-package magit
  :bind
  ("C-c m" . magit-status)

  :custom
  (magit-last-seen-setup-instructions "1.4.0"))
#+end_src

*** Markdown

Nothing exotic.

#+begin_src emacs-lisp
(use-package markdown-mode
  :hook
  ((markdown-mode . flyspell-mode)
   (markdown-mode . auto-fill-mode))
  :config
  (add-to-list 'auto-mode-alist '("\\.md" . markdown-mode)))
#+end_src

*** Projectile

I use [[https://github.com/bbatsov/projectile][Projectile]] for project management. It integrates nicely with Helm.

#+begin_src emacs-lisp
(use-package projectile
  :delight '(:eval (concat " " (projectile-project-name)))
  :bind
  (:map projectile-mode-map
        ("C-c p c" . projectile-compile-project))
  :init
  (projectile-global-mode))

(use-package helm-projectile
  :bind
  (:map projectile-mode-map
        ("C-c p f" . helm-projectile)
        ("C-c p p" . helm-projectile-switch-project)
        ("C-c p g" . helm-grep-do-git-grep)))

#+end_src

*** Text

I almost always want auto-wrapping at /some/ level, and spell checking
is welcome.

#+begin_src emacs-lisp
(use-package text-mode
  :hook
  ((text-mode . auto-fill-mode)
   (text-mode . flyspell-mode)))
#+end_src

*** Which function

I've run into issues with this interacting poorly with other modes,
and the code is probably fragile. I wish I'd commented it better when
I wrote it.

#+begin_src emacs-lisp
(use-package which-func
  :config
  (defconst
    my-which-func-current
    '(:eval (replace-regexp-in-string
	     "%" "%%"
             (let ((current-function (gethash (selected-window) which-func-table)))
               (if current-function
                   (propertize
                    current-function
                    'face 'font-lock-function-name-face)
                 (propertize "---" 'face 'shadow))))))

  (defconst
    my-which-func-format
    `("λ["
      (:propertize my-which-func-current
		   local-map ,which-func-keymap
		   mouse-face mode-line-highlight
		   help-echo "mouse-1: go to beginning\n\
mouse-2: toggle rest visibility\n\
mouse-3: go to end")
      "]"))

  (defconst my-which-func-header-line-format
    '(which-function-mode ("" my-which-func-format)))

  (defadvice which-func-ff-hook (after header-line activate)
    (when which-func-mode
      ;; We need to remove the which-function-mode configuration from the
      ;; mode line. It currently resides in mode-line-misc-info
      (setq
       mode-line-misc-info
       (delete
        (assoc 'which-function-mode mode-line-misc-info)
        mode-line-misc-info))
      ;; Set the header line
      (setq
       header-line-format
       my-which-func-header-line-format))))
#+end_src

*** Company

Company mode offers auto-completion capabilities.

#+begin_src emacs-lisp
(use-package company
  :diminish company-mode
  :hook
  (after-init . global-company-mode)

  :bind
  (:map company-mode-map
        ("C-:" . helm-company)
        ("C-;" . helm-company))
  (:map company-active-map
        ("C-:" . helm-company)
        ("C-;" . helm-company))

  :config
  (add-to-list 'company-backends 'company-c-headers)
  (setq company-idle-delay .2))
#+end_src
*** Ace jump

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :bind (("C-c SPC" . 'ace-jump-mode)))
#+end_src

*** Compilation mode

This allows compilation buffers to play nicely with colorization. See this
[[https://emacs.stackexchange.com/questions/24698/ansi-escape-sequences-in-compilation-mode][StackOverflow]] post, and in turn this [[http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html][blog post]] and this [[https://oleksandrmanzyuk.wordpress.com/2011/11/05/better-emacs-shell-part-i/][blog post]].

#+begin_src emacs-lisp
(use-package ansi-color
  :init
  (defun endless/colorize-compilation ()
    "Colorize from `compilation-filter-start' to `point'."
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region
       compilation-filter-start (point))))

  (add-hook 'compilation-filter-hook
            #'endless/colorize-compilation)

  (defun regexp-alternatives (regexps)
    "Return the alternation of a list of regexps."
    (mapconcat (lambda (regexp)
                 (concat "\\(?:" regexp "\\)"))
               regexps "\\|"))

  (defvar non-sgr-control-sequence-regexp nil
    "Regexp that matches non-SGR control sequences.")

  (setq non-sgr-control-sequence-regexp
        (regexp-alternatives
         '(;; icon name escape sequences
           "\033\\][0-2];.*?\007"
           ;; non-SGR CSI escape sequences
           "\033\\[\\??[0-9;]*[^0-9;m]"
           ;; noop
           "\012\033\\[2K\033\\[1F"
           )))

  (defun filter-non-sgr-control-sequences-in-region (begin end)
    (save-excursion
      (goto-char begin)
      (while (re-search-forward
              non-sgr-control-sequence-regexp end t)
        (replace-match ""))))

  (defun filter-non-sgr-control-sequences-in-output (ignored)
    (let ((start-marker
           (or comint-last-output-start
               (point-min-marker)))
          (end-marker
           (process-mark
            (get-buffer-process (current-buffer)))))
      (filter-non-sgr-control-sequences-in-region
       start-marker
       end-marker)))

  (add-hook 'comint-output-filter-functions
            'filter-non-sgr-control-sequences-in-output))
#+end_src

*** Eldoc

#+begin_src emacs-lisp
(use-package eldoc
  :diminish)
#+end_src

*** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :diminish flycheck-mode)
#+end_src

**** Smart mode line

I use the [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] package.

#+begin_src emacs-lisp
(use-package smart-mode-line
  :custom
  (sml/theme 'respectful)
  (sml/vc-mode-show-backend t)
  (sml/shorten-directory t)
  (sml/shorten-modes t)
  (sml/name-width 30)
  (sml/mode-width 'full))

(sml/setup)
#+end_src

*** Which key

Enable a helper mode showing completions of partially-entered key
chords. With this enabled, try typing ~C-c~ and waiting.

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode)
    :diminish which-key-mode)
#+end_src

** Programming modes
*** Org

I have some customization around capture templates that are based off
an old [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][coworker's configuration]].

#+begin_src emacs-lisp
  (use-package org
    :bind
    (("C-c l" . org-store-link)
     ("C-c a" . org-agenda)
     ("C-c c" . org-capture))

    :hook
    ((org-mode . auto-fill-mode)
     (org-mode . flyspell-mode))

    :custom
    (org-log-done 'time)
    (org-agenda-files (list "~/org/agenda.org"
                                "~/org/todo.org"
                                "~/org/journal.org"
                                "~/org/research.org"
                                "~/org/courses.org"))
    (org-refile-targets (quote ((nil :maxlevel . 9)
                                (org-agenda-files :maxlevel . 9)
                                ("~/.emacs.d/readme.org" :maxlevel . 9))))

    (org-capture-templates
         '(("t" "Todo" entry (file+headline "~/org/todo.org" "Tasks")
            "* TODO %?\n\nCreated at %U")
           ("j" "Journal" entry (file+datetree "~/org/journal.org")
            "* %?\nEntered on %U\n  %i\n  %a")
           ("r" "Research" entry (file+headline "~/org/research.org" "Research"))
           ("c" "Courses" entry (file+headline "~/org/courses.org" "Courses")))))
#+end_src

I don't use this much, and I inevitably modify it per machine.

*** Coq

All provided by the excellent [[https://proofgeneral.github.io/][Proof General]] package.

#+begin_src emacs-lisp
(use-package proof-general
  :bind
  (:map coq-mode-map
        (("RET" . newline-and-indent)))
  :custom
  (coq-compile-before-require t)
  :custom-face
  (proof-locked-face ((t (:extend t :background "#073642"))))
  (proof-queue-face ((t (:extend t :background "#d33682"))))
  :hook
  ((coq-mode . company-coq-mode)))
#+end_src

*** Haskell

It's convenient to have commands to run [[https://hackage.haskell.org/package/ormolu][Ormolu]].

#+begin_src emacs-lisp
(defcustom ormolu-command
  "ormolu"
  "The command to run when applying ormolu formatting"
  :type 'string
  :safe 'stringp
  :group 'prsteele)

(reformatter-define ormolu-format
  :program ormolu-command
  :args '()
  :lighter " ormolu")
#+end_src

Configure Haskell mode to use LSP. The use of ~hack-local-variables~
is unfortunate; I believe I added this to ensure that directory-local
variables are available when the LSP starts up, making it possible to
point to custom executables per directory.

#+begin_src emacs-lisp
(use-package haskell-mode
  :hook
  ((haskell-mode . (lambda ()
                     (hack-local-variables)
                     (lsp)))
   (haskell-mode . ormolu-format-on-save-mode))

  :config
  (setq haskell-process-wrapper-function
        (lambda (argv) (append (list "nix-shell" "-I" "." "--command" )
                               (list (mapconcat 'identity argv " ")))))

  ;; Turn off broken flymake functions
  (setq flymake-allowed-file-name-masks
	   (remove '("\\.l?hs\\'" haskell-flymake-init)
		   flymake-allowed-file-name-masks))
  )
#+end_src

*** LaTeX

Nothing exotic.

#+begin_src emacs-lisp
(use-package latex-mode
  :custom
  (font-latex-script-display 'nil)
  (font-latex-fontify-script 'nil)
  (font-latex-fontify-sectioning 'color)
  (show-trailing-whitespace 't)
  (tex-font-lock-suscript 'ignore)

  :hook
  ((latex-mode . auto-fill-mode)
   (latex-mode . flyspell-mode)))
#+end_src

*** prog-mode

There are some good global defaults for any ~prog-mode~-derived mode:

1. I want rainbow delimiters
2. I want rainbow identifiers
3. I want line numbers
4. I want to see trailing whitespace (so I can get rid of it, if
   somehow an auto-formatter doesn't)

#+begin_src emacs-lisp
(use-package prog-mode
  :after (rainbow-delimiters rainbow-identifiers)
  :bind
  (:map prog-mode-map
        ("C-." . 'xref-find-definitions)
        ("C-," . 'xref-pop-marker-stack)
        ("C-c ?" . 'eglot-help-at-point))

  :hook
  ((prog-mode . display-line-numbers-mode)
   (prog-mode . electric-pair-mode)
   (prog-mode . rainbow-delimiters-mode)
   (prog-mode . rainbow-identifiers-mode))

  :custom
  (show-trailing-whitespace 't))

(use-package comint
  :custom
  (show-trailing-whitespace nil))
#+end_src

*** Python

Both [[https://github.com/psf/black][black]] and [[https://github.com/PyCQA/isort][isort]] are incredibly useful to have enabled on save.

#+begin_src emacs-lisp
(defvar-local isort-command "isort" "The command to run when applying isort formatting")

(reformatter-define isort-format
  :program isort-command
  :args '("-")
  :lighter " isort")

(defvar-local black-command "black" "The command to run when applying isort formatting")

(reformatter-define black-format
  :program black-command
  :args '("-")
  :lighter " black")

#+end_src

I use a variety of LSP backends for Python. I prefer [[https://github.com/microsoft/pyright][Pyright]], but I've
used others. I prefer ~lsp-mode~ as a frontend, but configure ~eglot~
as well, which seems to work better on large code bases.

#+begin_src emacs-lisp
(defcustom prsteele-python-mode-lsp-server-path
  "pyls"
  "The path to the Python language server program"
  :type 'string
  :safe 'stringp
  :group 'prsteele)

(defun eglot-python-lsp-server-fn (was-interactive)
  "A function to compute the LSP server for Python"
  (list prsteele-python-mode-lsp-server-path))

(use-package lsp-pyright
  :custom
  (lsp-pyright-multi-root nil))

(use-package python
  :bind
  (:map python-mode-map
        (("C-c C-l" . python-shell-send-buffer)))
  :hook
  ((python-mode . lsp))
  ((python-mode . isort-format-on-save-mode))
  ((python-mode . black-format-on-save-mode))
  :config
  (add-to-list 'eglot-server-programs '(python-mode . eglot-python-lsp-server-fn)))
#+end_src

**** SCons

SCons files are just Python.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("SConstruct" . python-mode))
(add-to-list 'auto-mode-alist '("SConscript" . python-mode))
#+end_src

*** SQL

It's nice having a default backend.

#+begin_src emacs-lisp
(use-package sql
  :custom
  (sql-product "postgres"))
#+end_src

*** Elisp mode

#+begin_src
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+end_src

*** reStructuredText mode

I don't use this often, and I should probably just enable
~flyspell-mode~ and ~auto-fill-mode~ from a suitable ancestor mode.

#+begin_src emacs-lisp
(use-package rst
  :hook
  ((rst-mode . flyspell-mode)
   (rst-mode . auto-fill-mode)))
#+end_src

** Nix

This is absolutely computer-specific.

#+begin_src emacs-lisp
(setenv "NIX_PATH" "/home/prsteele/.nix-defexpr/channels")
(setenv "NIX_PROFILES" "/nix/var/nix/profiles/default /home/prsteele/.nix-profile")
(setenv "NIX_SSL_CERT_FILE" "/etc/ssl/certs/ca-certificates.crt")
#+end_src

** Closing

#+begin_src emacs-lisp
  (server-start)
  (provide 'init)
#+end_src
