* Emacs configuration

This file is a literate Elisp file; this approach is inspired by
[[https://github.com/patrickt/emacs]].

** A note on package management

I don't like that MELPA et al. don't allow rollbacks. To solve this, I
track all installed packages in a Git repository. This might be a
terrible idea, but so far it works well enough (and how often do I
ever need to roll back? Still, it's nice to have.) I clone the
[[https://github.com/prsteele/emacs-elpa][emacs-elpa]] repository to the ~elpa/~ directory. (I clone directly
instead of using `git submodule` so that package update operations
modify an actual Git repository, which makes committing new changes
easy.)

You can, of course, simply not do this. This configuration doesn't
know this happening, so that directory can just be a regular old
directory.

** Cruft

Somehow, ~LD_PRELOAD~ is set. Unset it.

#+begin_src emacs-lisp
(setenv "LD_PRELOAD" "")
#+end_src

Define a customization group for my variables.

#+begin_src emacs-lisp
(defgroup prsteele nil
  "My customizations."
  :prefix "prsteele-"
  :group 'applications)
#+end_src


** General configuration

Use spaces, not tabs.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Some commands are disabled by default, and I don't want warnings when
I invoke them.

#+begin_src emacs-lisp
(mapc
 #'(lambda (x) (put x 'disabled nil))
 '(upcase-region
   downcase-region
   narrow-to-region))
#+end_src

It's nice to have ~PATH~ set as you might expect, and this package
helps do so:

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize))
#+end_src

I've run into issues where libraries assume that ~tramp~ is loaded,
and it doesn't hurt to do so.

#+begin_src emacs-lisp
(require 'tramp)
#+end_src

Enable a helper mode showing completions of partially-entered key
chords. With this enabled, try typing ~C-c~ and waiting.

#+begin_src emacs-lisp
(use-package which-key
  :config (which-key-mode)
  :diminish which-key-mode)
#+end_src

** Ace jump mode

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :bind (("C-c SPC" . 'ace-jump-mode)))
#+end_src

** General appearance

I really don't want menu bars, tool bars, or scroll bars.

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(set-scroll-bar-mode 'nil)
(show-paren-mode 't)
(column-number-mode 't)
#+end_src

Parenthesis matching and visual column numbers are useful.

#+begin_src emacs-lisp
(show-paren-mode 't)
(column-number-mode 't)
#+end_src

*** Font

#+begin_src emacs-lisp
(set-frame-font "Noto Sans Mono 12")

(use-package solarized-theme
  :init
  (load-theme 'solarized-dark t))

(use-package rainbow-delimiters)
(use-package rainbow-identifiers)
#+end_src

*** Theme

[[https://ethanschoonover.com/solarized/][Solarized]] is a nice color scheme. Additionally, I find labeling
delimiters and words with different colors useful.

#+begin_src emacs-lisp
(use-package solarized-theme
  :init
  (load-theme 'solarized-dark t))
(use-package rainbow-delimiters)
(use-package rainbow-identifiers)
#+end_src

*** Window manager compatibility

This is needed to avoid small gaps around graphical Emacs on some
systems.

#+begin_src emacs-lisp
(setq frame-resize-pixelwise t)
#+end_src

*** Trailing whitespace

I want this enabled or disabled in a number of modes

**** Disabled

#+begin_src emacs-lisp
(use-package compile
  :hook
  ((compilation-mode . disable-trailing-whitespace)))

(use-package shell
  :hook
  ((shell-mode . disable-trailing-whitespace)))

(use-package term
  :hook
  ((term-mode . disable-trailing-whitespace)))

#+end_src

*** Compilation mode

This allows compilation buffers to play nicely with colorization. See this
[[https://emacs.stackexchange.com/questions/24698/ansi-escape-sequences-in-compilation-mode][StackOverflow]] post, and in turn this [[http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html][blog post]] and this [[https://oleksandrmanzyuk.wordpress.com/2011/11/05/better-emacs-shell-part-i/][blog post]].

#+begin_src emacs-lisp
(use-package ansi-color
  :init
  (defun endless/colorize-compilation ()
    "Colorize from `compilation-filter-start' to `point'."
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region
       compilation-filter-start (point))))

  (add-hook 'compilation-filter-hook
            #'endless/colorize-compilation)

  (defun regexp-alternatives (regexps)
    "Return the alternation of a list of regexps."
    (mapconcat (lambda (regexp)
                 (concat "\\(?:" regexp "\\)"))
               regexps "\\|"))

  (defvar non-sgr-control-sequence-regexp nil
    "Regexp that matches non-SGR control sequences.")

  (setq non-sgr-control-sequence-regexp
        (regexp-alternatives
         '(;; icon name escape sequences
           "\033\\][0-2];.*?\007"
           ;; non-SGR CSI escape sequences
           "\033\\[\\??[0-9;]*[^0-9;m]"
           ;; noop
           "\012\033\\[2K\033\\[1F"
           )))

  (defun filter-non-sgr-control-sequences-in-region (begin end)
    (save-excursion
      (goto-char begin)
      (while (re-search-forward
              non-sgr-control-sequence-regexp end t)
        (replace-match ""))))

  (defun filter-non-sgr-control-sequences-in-output (ignored)
    (let ((start-marker
           (or comint-last-output-start
               (point-min-marker)))
          (end-marker
           (process-mark
            (get-buffer-process (current-buffer)))))
      (filter-non-sgr-control-sequences-in-region
       start-marker
       end-marker)))

  (add-hook 'comint-output-filter-functions
            'filter-non-sgr-control-sequences-in-output))
#+end_src


** Coq support

All provided by the excellent [[https://proofgeneral.github.io/][Proof General]] package.

#+begin_src emacs-lisp
(use-package proof-general
  :bind
  (:map coq-mode-map
        (("RET" . newline-and-indent)))
  :custom
  (coq-compile-before-require t)
  :custom-face
  (proof-locked-face ((t (:extend t :background "#073642"))))
  (proof-queue-face ((t (:extend t :background "#d33682"))))
  :hook
  ((coq-mode . company-coq-mode)))
#+end_src

** Company mode

Company mode offers auto-completion capabilities.

#+begin_src emacs-lisp
(use-package company
  :diminish company-mode
  :hook
  (after-init . global-company-mode)

  :bind
  (:map company-mode-map
        ("C-:" . helm-company)
        ("C-;" . helm-company))
  (:map company-active-map
        ("C-:" . helm-company)
        ("C-;" . helm-company))

  :config
  (add-to-list 'company-backends 'company-c-headers)
  (setq company-idle-delay .2))
#+end_src
** Eldoc mode

Just diminish it.

#+begin_src emacs-lisp
(use-package eldoc
  :diminish)
#+end_src

** Elisp mode

#+begin_src
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
#+end_src

** Flycheck mode

Just diminish it.

#+begin_src emacs-lisp
(use-package flycheck
  :diminish flycheck-mode)
#+end_src

** Flymake mode

Diminish it, and avoid the creation of temporary files. (The temporary
files can wreak havoc on sufficiently advanced IDE features.)

#+begin_src emacs-lisp
(use-package flymake
  :diminish
  :custom
  (flymake-run-in-place nil))
#+end_src

** Haskell mode

It's convenient to have commands to run [[https://hackage.haskell.org/package/ormolu][Ormolu]].

#+begin_src emacs-lisp
(defcustom ormolu-command
  "ormolu"
  "The command to run when applying ormolu formatting"
  :type 'string
  :safe 'stringp
  :group 'prsteele)

(reformatter-define ormolu-format
  :program ormolu-command
  :args '()
  :lighter " ormolu")
#+end_src

Configure Haskell mode to use LSP. The use of ~hack-local-variables~
is unfortunate; I believe I added this to ensure that directory-local
variables are available when the LSP starts up, making it possible to
point to custom executables per directory.

#+begin_src emacs-lisp
(use-package haskell-mode
  :hook
  ((haskell-mode . (lambda ()
                     (hack-local-variables)
                     (lsp)))
   (haskell-mode . ormolu-format-on-save-mode))

  :config
  (setq haskell-process-wrapper-function
        (lambda (argv) (append (list "nix-shell" "-I" "." "--command" )
                               (list (mapconcat 'identity argv " ")))))

  ;; Turn off broken flymake functions
  (setq flymake-allowed-file-name-masks
	   (remove '("\\.l?hs\\'" haskell-flymake-init)
		   flymake-allowed-file-name-masks))
  )
#+end_src

** Helm mode

I use Helm for narrowing and completion.

#+begin_src emacs-lisp
(use-package helm-config)

(use-package helm
  :diminish
  :config
  (global-unset-key (kbd "C-x c"))
  (global-unset-key (kbd "C-x C-x"))

  :bind
  (("M-x" . helm-M-x)
   ("C-x C-x" . helm-M-x)
   ("C-x b" . helm-buffers-list)
   ("C-h SPC" . helm-all-mark-rings)
   ("C-x C-f" . helm-find-files)
   (:map helm-command-map
         (("<tab>" . helm-execute-persistent-action)
          ("C-i" . helm-execute-persistent-action)
          ("C-z" . helm-select-action))))

  :bind-keymap
  ("C-c h" . helm-command-prefix)


  :custom
  (helm-quick-update t)
  (helm-split-window-in-side-p t)
  (helm-buffers-fuzzy-matching t)
  (helm-move-to-line-cycle-in-source t)
  (helm-ff-search-library-in-sexp t)
  (helm-scroll-amount 8)
  (helm-ff-file-name-history-use-recentf t)
  (helm-buffer-max-length . nil)

  :init
  (helm-mode 1))

(use-package helm-grep
  :bind
  (:map helm-grep-mode-map
        ("<return>" . helm-grep-mode-jump-other-window)
        ("n" . helm-grep-mode-jump-other-window-forward)
        ("p" . helm-grep-mode-jump-other-window-backward)))

(use-package helm-eshell)
(use-package helm-files)
#+end_src

** LaTeX mode

Nothing exotic.

#+begin_src emacs-lisp
(use-package latex-mode
  :custom
  (font-latex-script-display 'nil)
  (font-latex-fontify-script 'nil)
  (font-latex-fontify-sectioning 'color)
  (show-trailing-whitespace 't)
  (tex-font-lock-suscript 'ignore)

  :hook
  ((latex-mode . auto-fill-mode)
   (latex-mode . flyspell-mode)))
#+end_src

** LSP mode

I use `lsp-mode` and `lsp-ui-mode` as my frontend for the various
language server protocol servers. This configuration should largely
follow what is suggested on [[https://github.com/emacs-lsp/lsp-mode][their home page]].

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands lsp
  :diminish "LSP"
  :hook
  ((lsp-mode . lsp-enable-which-key-integration))
  :custom
  (lsp-enable-snippet nil)
  (lsp-prefer-flymake nil)
  (lsp-signature-auto-activate nil)
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\.hypothesis\\'")
  )

(use-package lsp-ui
  :commands lsp-ui-mode

 :bind
 (:map lsp-ui-mode-map
       ("C-c ?" . 'lsp-ui-doc-show-or-focus)
       ("C-." . 'lsp-ui-peek-find-definitions)
       ("M-." . 'lsp-ui-peek-find-references)
       ("C-," . 'xref-pop-marker-stack)
       ("C-c r" . 'lsp-rename)))

(defun lsp-ui-doc-show-or-focus (arg)
  (interactive "P")
  (if arg
      (lsp-ui-doc-focus-frame)
    (lsp-ui-doc-show)))

(use-package lsp-ui-doc
  ;; :hook
  ;; ((lsp-ui-doc-frame . (lambda (frame window) (message "got here"))))
  :bind
  (:map lsp-ui-doc-frame-mode-map
        ("C-c ?" . 'lsp-ui-doc-unfocus-frame)))

(add-hook
 'lsp-ui-doc-frame-hook
 (lambda (frame window)
   (set-frame-font "Noto Sans Mono 12" nil (list frame))))
#+end_src

We want to hook into Helm:

#+begin_src emacs-lisp
(use-package helm-lsp
  :commands helm-lsp-workspace-symbol)
#+end_src

I sometimes use ~eglot~ instead of ~lsp-mode~, so I leave its
configuration intact.

#+begin_src emacs-lisp
(use-package eglot
  :bind
  (:map eglot-mode-map
        ("C-." . 'xref-find-definitions)
        ("C-," . 'xref-pop-marker-stack)
        ("C-c ?" . 'eglot-help-at-point)
        ("C-c C-c" . 'eglot-code-actions)))
#+end_src

** Magit mode

Nothing exotic.

#+begin_src emacs-lisp
(use-package magit
  :bind
  ("C-c m" . magit-status)

  :custom
  (magit-last-seen-setup-instructions "1.4.0"))
#+end_src

** Markdown mode

Nothing exotic.

#+begin_src emacs-lisp
(use-package markdown-mode
  :hook
  ((markdown-mode . flyspell-mode)
   (markdown-mode . auto-fill-mode))
  :config
  (add-to-list 'auto-mode-alist '("\\.md" . markdown-mode)))
#+end_src

** Mode line configuration

I use the [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] package.

#+begin_src emacs-lisp
(use-package smart-mode-line
  :custom
  (sml/theme 'respectful)
  (sml/vc-mode-show-backend t)
  (sml/shorten-directory t)
  (sml/shorten-modes t)
  (sml/name-width 30)
  (sml/mode-width 'full))

(sml/setup)
#+end_src

** Nix

This is absolutely computer-specific.

#+begin_src emacs-lisp
(setenv "NIX_PATH" "/home/prsteele/.nix-defexpr/channels")
(setenv "NIX_PROFILES" "/nix/var/nix/profiles/default /home/prsteele/.nix-profile")
(setenv "NIX_SSL_CERT_FILE" "/etc/ssl/certs/ca-certificates.crt")
#+end_src

** Org mode

I have some customization around capture templates that are based off
an old [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][coworker's configuration]].

#+begin_src emacs-lisp
(use-package org
  :bind
  (("C-c l" . org-store-link)
   ("C-c a" . org-agenda)
   ("C-c c" . org-capture))

  :hook
  ((org-mode . auto-fill-mode)
   (org-mode . flyspell-mode))

  :custom
  (org-log-done 'time)
  (org-agenda-files (list "~/org/agenda.org"
                              "~/org/todo.org"
                              "~/org/journal.org"
                              "~/org/research.org"
                              "~/org/courses.org"))
  (org-refile-targets (quote ((nil :maxlevel . 9)
                              (org-agenda-files :maxlevel . 9))))

  (org-capture-templates
       '(("t" "Todo" entry (file+headline "~/org/todo.org" "Tasks")
          "* TODO %?\n\nCreated at %U")
         ("j" "Journal" entry (file+datetree "~/org/journal.org")
          "* %?\nEntered on %U\n  %i\n  %a")
         ("r" "Research" entry (file+headline "~/org/research.org" "Research"))
         ("c" "Courses" entry (file+headline "~/org/courses.org" "Courses")))))
#+end_src

I don't use this much, and I inevitably modify it per machine.

** Prog mode

There are some good global defaults for any ~prog-mode~-derived mode:

1. I want rainbow delimiters
2. I want rainbow identifiers
3. I want line numbers
4. I want to see trailing whitespace (so I can get rid of it, if
   somehow an auto-formatter doesn't)

#+begin_src emacs-lisp
(use-package prog-mode
  :after (rainbow-delimiters rainbow-identifiers)
  :bind
  (:map prog-mode-map
        ("C-." . 'xref-find-definitions)
        ("C-," . 'xref-pop-marker-stack)
        ("C-c ?" . 'eglot-help-at-point))

  :hook
  ((prog-mode . display-line-numbers-mode)
   (prog-mode . electric-pair-mode)
   (prog-mode . rainbow-delimiters-mode)
   (prog-mode . rainbow-identifiers-mode))

  :custom
  (show-trailing-whitespace 't))

(use-package comint
  :custom
  (show-trailing-whitespace nil))
#+end_src

** Projectile mode

I use [[https://github.com/bbatsov/projectile][Projectile]] for project management. It integrates nicely with Helm.

#+begin_src emacs-lisp
(use-package projectile
  :delight '(:eval (concat " " (projectile-project-name)))
  :bind
  (:map projectile-mode-map
        ("C-c p c" . projectile-compile-project))
  :init
  (projectile-global-mode))

(use-package helm-projectile
  :bind
  (:map projectile-mode-map
        ("C-c p f" . helm-projectile)
        ("C-c p p" . helm-projectile-switch-project)
        ("C-c p g" . helm-grep-do-git-grep)))

#+end_src

** Python mode

Both [[https://github.com/psf/black][black]] and [[https://github.com/PyCQA/isort][isort]] are incredibly useful to have enabled on save.

#+begin_src emacs-lisp
(defvar-local isort-command "isort" "The command to run when applying isort formatting")

(reformatter-define isort-format
  :program isort-command
  :args '("-")
  :lighter " isort")

(defvar-local black-command "black" "The command to run when applying isort formatting")

(reformatter-define black-format
  :program black-command
  :args '("-")
  :lighter " black")

#+end_src

I use a variety of LSP backends for Python. I prefer [[https://github.com/microsoft/pyright][Pyright]], but I've
used others. I prefer ~lsp-mode~ as a frontend, but configure ~eglot~
as well, which seems to work better on large code bases.

#+begin_src emacs-lisp
(defcustom prsteele-python-mode-lsp-server-path
  "pyls"
  "The path to the Python language server program"
  :type 'string
  :safe 'stringp
  :group 'prsteele)

(defun eglot-python-lsp-server-fn (was-interactive)
  "A function to compute the LSP server for Python"
  (list prsteele-python-mode-lsp-server-path))

(use-package lsp-pyright
  :custom
  (lsp-pyright-multi-root nil))

(use-package python
  :bind
  (:map python-mode-map
        (("C-c C-l" . python-shell-send-buffer)))
  :hook
  ((python-mode . lsp))
  ((python-mode . isort-format-on-save-mode))
  ((python-mode . black-format-on-save-mode))
  :config
  (add-to-list 'eglot-server-programs '(python-mode . eglot-python-lsp-server-fn)))
#+end_src

*** SCons

SCons files are just Python.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("SConstruct" . python-mode))
(add-to-list 'auto-mode-alist '("SConscript" . python-mode))
#+end_src

** reStructuredText mode

I don't use this often, and I should probably just enable
~flyspell-mode~ and ~auto-fill-mode~ from a suitable ancestor mode.

#+begin_src emacs-lisp
(use-package rst
  :hook
  ((rst-mode . flyspell-mode)
   (rst-mode . auto-fill-mode)))
#+end_src

** SQL mode

It's nice having a default backend.

#+begin_src emacs-lisp
(use-package sql
  :custom
  (sql-product "postgres"))
#+end_src

** Text editing

I almost always want auto-wrapping at /some/ level, and spell checking
is welcome.

#+begin_src emacs-lisp
(use-package text-mode
  :hook
  ((text-mode . auto-fill-mode)
   (text-mode . flyspell-mode)))
#+end_src

** Which function mode

I've run into issues with this interacting poorly with other modes,
and the code is probably fragile. I wish I'd commented it better when
I wrote it.

#+begin_src emacs-lisp
(use-package which-func
  :config
  (defconst
    my-which-func-current
    '(:eval (replace-regexp-in-string
	     "%" "%%"
             (let ((current-function (gethash (selected-window) which-func-table)))
               (if current-function
                   (propertize
                    current-function
                    'face 'font-lock-function-name-face)
                 (propertize "---" 'face 'shadow))))))

  (defconst
    my-which-func-format
    `("λ["
      (:propertize my-which-func-current
		   local-map ,which-func-keymap
		   mouse-face mode-line-highlight
		   help-echo "mouse-1: go to beginning\n\
mouse-2: toggle rest visibility\n\
mouse-3: go to end")
      "]"))

  (defconst my-which-func-header-line-format
    '(which-function-mode ("" my-which-func-format)))

  (defadvice which-func-ff-hook (after header-line activate)
    (when which-func-mode
      ;; We need to remove the which-function-mode configuration from the
      ;; mode line. It currently resides in mode-line-misc-info
      (setq
       mode-line-misc-info
       (delete
        (assoc 'which-function-mode mode-line-misc-info)
        mode-line-misc-info))
      ;; Set the header line
      (setq
       header-line-format
       my-which-func-header-line-format))))
#+end_src
